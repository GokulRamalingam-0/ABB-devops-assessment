# Starter pipeline
# Start with a minimal pipeline that you can customize to build and deploy your code.
# Add steps that build, run tests, deploy, and more:
# https://aka.ms/yaml

trigger:
- main

variables:
  registry: assessment.azurecr.io
  repository: nodeapp
  tag: "$(Build.BuildId)"

stages:
  - stage: build
    displayName: "Build Docker Image"
    pool:
      name: default
    jobs:
      - job: checkout
        displayName: Checkout from github repo

        steps:
          - checkout: self
          - task: Docker@2
            displayName: Build Image
            inputs:
              command: build
              Dockerfile: "Dockerfile"
              repository: "$(repository)"
              tags: |
                $(tag)
              #containerRegistry: "none"
              addPipelineData: false

          - script: |
              docker save $(repository):$(tag) | gzip > $(Build.ArtifactStagingDirectory)/image.tar.gz
            displayName: Export Image

          - publish: $(Build.ArtifactStagingDirectory)/image.tar.gz
            artifact: image-tar

# ---------------------- Sample Unit Test ------------------------------------
  - stage: test
    displayName: Unit tests
    dependsOn: build
    pool:            # keep using your SelfHosted agent
      name: default
    jobs:
    - job: unit
      displayName: Run unit tests
      steps:
      - checkout: self

    # install deps â€“ honour package-lock.json if present
      - script: |
          npm install
        displayName: npm install

    # run tests and output JUnit XML named test-results.xml
      - script: |
          npm test -- --reporter mocha-junit-reporter --reporter-options mochaFile=test-results.xml
        displayName: Execute tests

    # publish results so they appear in the Tests tab
      - task: PublishTestResults@2
        inputs:
          testResultsFormat: JUnit
          testResultsFiles: '**/test-results.xml'
          failTaskOnFailedTests: true
        condition: succeededOrFailed()

#---------------------------- Scan ---------------------------
  - stage: scan
    displayName: Scan with trivy
    dependsOn: test
    pool:
      name: default
    jobs:
      - job: scan
        steps:
          - download: current
            artifact: image-tar

          - script: |
              gunzip -c $(Pipeline.Workspace)/image-tar/image.tar.gz | docker load
              trivy image --severity CRITICAL --exit-code 1 $(repository):$(tag)
            displayName: Run vulnerability scan

#------------------- Push ----------------------------------

  - stage: push
    displayName: Push Image
    dependsOn: scan
    condition: succeeded()
    pool:
      name: default
    jobs:
      - job: push
 
        steps:
          - download: current
            artifact: image-tar

          - script: |
              gunzip -c $(Pipeline.Workspace)/image-tar/image.tar.gz | docker load
            displayName: Load image

          - script: |
              echo "$DOCKER_PASS" | docker login $(registry) -u "$DOCKER_USER" --password-stdin
            displayName: Docker Login
            env:
              DOCKER_USER: $(DOCKER_USER)
              DOCKER_PASS: $(DOCKER_PASS)

          - script: | 
              docker tag $(repository):$(tag) $(registry)/$(repository):$(tag)
              docker push $(registry)/$(repository):$(tag)
            displayName: Tag & Push

#------------------- Deploy to Web App (Dev) ---------------------------
  - stage: deploy_dev
    displayName: "Deploy to Azure Web App (Dev)"
    dependsOn: push
    condition: succeeded()
    pool:
      name: default
    jobs:
      - job: deploy_dev
        displayName: "Deploy container to Azure Web App"
        steps:
          - script: |
              az webapp config container set --name nodejs --resource-group kml_rg_main-167d6474acbb46c7 --docker-custom-image-name assessment.azurecr.io/nodeapp:$(Build.BuildId) --docker-registry-server-url https://assessment.azurecr.io --docker-registry-server-user $(DOCKER_USER) --docker-registry-server-password $(DOCKER_PASS)

# ------------------- Deploy to AKS (PROD, with approvals via Environment) -------------------
  - stage: deploy_prod
    displayName: Deploy to AKS (Prod)
    dependsOn: push
    condition: succeeded()
    pool:
      name: default
    jobs:
      - deployment: deploy_prod
        displayName: Helm deploy to AKS
        environment:
          name: prod
          resourceType: Kubernetes
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                
                - script: |
                    # Authenticate and fetch kubeconfig for AKS
                    az aks get-credentials \
                      --resource-group kml_rg_main-167d6474acbb46c7 \
                      --name many-dogfish-aks \
                      --overwrite-existing

                    # Deploy with Helm (wait & rollback on failure)
                    helm upgrade --install nodeapp-prod ./charts/nodeapp \
                      --namespace default \
                      --create-namespace \
                      --set image.repository=$(registry)/$(repository) \
                      --set image.tag=$(tag) \
                      --set service.port=80 \
                      --set service.targetPort=80 \
                      --wait --atomic --timeout 5m

                    # (Optional) Verify rollout explicitly
                    kubectl rollout status deploy/nodeapp-prod-deployment -n default --timeout=180s
                    kubectl get pods,svc -o wide